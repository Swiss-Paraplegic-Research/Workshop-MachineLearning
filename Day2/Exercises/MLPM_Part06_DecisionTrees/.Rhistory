tr <- ctree(type ~ ., data = Pima.tr)
tr
# Chunk 4
plot(tr)
# Chunk 5
str(Pima.te)
pred_tr <- predict(tr, newdata=Pima.te, type='response')
# Confusion matrix:
confT <- table(pred_tr, Pima.te$type)
confT
# Test error:
missMat <- confT
diag(missMat) <- 0
test_err <- sum(missMat)/sum(confT)
test_err
# Chunk 6
### Adapted CV function:
tree_CV <- function(data, label, k_fold=10){
# Create k sub-selections:
n <- nrow(data)
ind_s <- sample(1:n)
ind.L <- list()
j1 <- 1
for (i in 1:k_fold){
j2 <- (i*n) %/% k_fold
ind.L[[i]] <- ind_s[j1:j2]
j1 <- j2+1
}
# Fit decision tree to each selection (and collect results):
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
for(fold in 1:k_fold){
ind_fold <- ind.L[[fold]]
testDat <- data[ind_fold,]
test.solu <- label[ind_fold]
trainDat <- data[-ind_fold,]
train.solu <- label[-ind_fold]
trainDat_tr <- cbind(y=train.solu, trainDat)   # Need labels and predictors
# in one data frame for ctree
tr <- partykit::ctree(y ~., data = trainDat_tr)
tr_preds <- predict(tr, newdata = testDat)
confMat.fold <-  table(tr_preds, test.solu)
confMat <- confMat + confMat.fold
}
# Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
test.err <- sum(missMat)/sum(confMat)
L.res <- list(k_fold=k_fold, confMatrix=confMat, errorRate=test.err)
return(L.res)
}
### Apply function:
Pima.comb <- rbind(Pima.tr, Pima.te)   # Combine data sets
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
nicePairsPlot(Pima.comb)
nicePairsPlot(Pima.comb, loess = TRUE)
nicePairsPlot(Pima.comb, loess = TRUE, catVar = Pima.comb$type)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
set.seed(2983)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
set.seed(2983)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
set.seed(2983)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
str(Pima.comb)
frs <- cforest(type ~ ., data = Pima.comb)
?cforest
frs <- cforest(type ~ ., data = Pima.comb, ntree = 1000)
library(beepr)
beep()
predict(frs, OOB = TRUE)
frs_p <- predict(frs, OOB = TRUE)
frs_p
confMat
confM
confM <- table(frs_p, Pima.comb$type)
confM
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
sum(missm)/sum(confM)
frs <- cforest(type ~ ., data = Pima.comb, ntree = 500)
frs_p <- predict(frs, OOB = TRUE)
confM <- table(frs_p, Pima.comb$type)
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
frs <- cforest(type ~ ., data = Pima.tr, ntree = 500)
frs_p <- predict(frs, OOB = TRUE)
confM <- table(frs_p, Pima.tr$type)
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
confM
confT
frs_p <- predict(frs, newdata = Pima.te)
confM <- table(frs_p, Pima.te$type)
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
confM
confM
confT
getwd()
rm(list=ls())
load('./dat_smoking.rda')
ls()
head(dat_smoking)
nicePairsPlot(dat_smoking)
sum(missm)/sum(confM)
ls()
nicePairsPlot(dat_smoking, loess = TRUE)
ls()
frs <- cforest(alcohol_per_month ~ ., data = dat_smoking, ntree = 500)
Pima.te
nicePairsPlot(Pima.tr)
?Pima.te
head(Pima.tr)
tr_glu <- ctree(glu ~ ., data = Pima.tr)
plot(tr_glu)
nicePairsPlot(Pima.tr)
lm(glu ~ ., Pima.tr)
summary(lm(glu ~ ., Pima.tr))
tr_glu <- ctree(glu ~ ., data = Pima.tr)
plot(tr_glu)
str(Pima.tr)
tr
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
pred_tr <- predict(tr, newdata=Pima.te, type='response')
pred_tr <- predict(tr, newdata=Pima.te)
predict(tr, newdata=Pima.te)
predict(tr, newdata=Pima.te, type='response')
predict(tr, newdata=Pima.te, type='prob')
ctree.iris <- ctree(Sepal.Length ~., data=iris)  # fit regression tree
predict(ctree.iris, newdata=iris, type='response')
pred_glu <- predict(tr_glu, newdata = Pima.te)
pred_glu
class(tr_glu)
?predict.party
?predict_party
predict_party
predict.party
pred_glu <- predict(tr_glu, newdata = Pima.te)
pred_glu
plot(x = pred_glu, y = Pima.te$glu, ylab = 'true glu values', xlab = 'predicted glu values')
pred_glu <- predict(tr_glu, newdata = Pima.te)
### MSE:
pred_glu - Pima.te$glu
### MSE:
(pred_glu - Pima.te$glu)^2
### MSE:
mean((pred_glu - Pima.te$glu)^2)
### MSE:
mse_tree <- mean((pred_glu - Pima.te$glu)^2)
mse_tree
lm_glu <- lm(glu ~ ., data = Pima.tr)
summary(lm_glu)
predlm_glu <- predict(lm_glu, newdata = Pima.te)
predlm_glu
mse_lm <- mean((predlm_glu - Pima.te$glu)^2)
mse_lm
mse_tree
plot(x = predlm_glu, y = Pima.te$glu)
c('MSE_tree'=mse_tree, 'MSE_lm'=mse_lm)
for_glu <- cforest(glu ~., data = Pima.tr, ntree = 1000)
beep()
pred_for <- predict(for_glu, newdata = Pima.te)
pred_for
mse_for <- mean((pred_for - Pima.te$glu)^2)
mse_for
plot(pred_for, Pima.te$glu)
nicePairsPlot(Pima.tr)
d <- Pima.tr[, c("bp", "glu", "age")]
nice3DPlot(d)
nice3DPlot(standizDat(d))
nice3DPlot(standizDat(d), plotFit = 'lin')
rm(list=ls8)
rm(list=ls())
ls()
load("/home/yrothacher/Desktop/PostDoc_Unterlagen/Arbeit/Workshops/myWorkshops/Swiss_Psychological_Society_2022/Machine_Learning_Workshop/myMaterial/Slides/dat_smoking.rda")
ls()
nicePairsPlot(dat_smoking)
ls()
str(dat_smoking)
colnames(dat_smoking)
paste(colnames(dat_smoking))
paste(colnames(dat_smoking), collapse = '')
paste(colnames(dat_smoking), collapse = ' ')
paste(colnames(dat_smoking), collapse = ', ')
ls()
library(MASS)
d <- rbind(Pima.tr, Pima.te)   # Combine data sets
head(d)
str(d)
library(CustomFunctionsYrotha)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type)
d <- standizDat(d)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type)
d <- rbind(Pima.tr, Pima.te)   # Combine data sets
d <- standizDat(d, chngName = FALSE)
library(CustomFunctionsYrotha)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'lin')
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'int')
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'int2')
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'int3')
library(MASS)
head(Pima.tr)
str(Pima.tr)
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
library(CustomFunctionsYrotha)
setUpGraph()
tr_glu <- ctree(glu ~ ., data = Pima.tr)
plot(tr_glu)
head(Pima.tr)
nicePairsPlot(Pima.tr)
nicePairsPlot(Pima.tr, loess = TRUE)
nice3DPlot(Pima.tr[, c("age", "glu", "bp")])
d <- Pima.tr[, c("age", "glu", "bp")]
head(d)
d <- Pima.tr[, c("age", "glu", "bp", "type")]
head(d)
str(d)
d <- standizDat(d, chngName = FALSE)
head(d)
str(d)
nice3DPlot(d[, -4], catVar = d$type)
nice3DPlot(d[, -4], catVar = d$type, plotFit = 'lin')
nice3DPlot(d[, -4], catVar = d$type, plotFit = 'int')
nice3DPlot(d[, -4], catVar = d$type, plotFit = 'int2')
library(CustomFunctionsYrotha)
library(MASS)
head(Pima.tr)
str(Pima.tr)
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
setUpGraph()
plot(tr)
str(Pima.te)
pred_tre <- predict(tr, newdata=Pima.te, type='response')
# Confusion matrix:
confT <- table(pred_tre, Pima.te$type)
confT
# Test error:
missMat <- confT
diag(missMat) <- 0
test_err <- sum(missMat)/sum(confT)
test_err
tr_glu <- ctree(glu ~ ., data = Pima.tr)
plot(tr_glu)
pred_glu <- predict(tr_glu, newdata = Pima.te)
### MSE:
mse_tree <- mean((pred_glu - Pima.te$glu)^2)
mse_tree
ls()
nicePairsPlot(rbind(Pima.tr, Pima.te))
library(MASS)
head(Pima.tr)
tr <- ctree(type ~ ., data = Pima.tr)
tr <- partykit::ctree(type ~ ., data = Pima.tr)
tr
plot(tr)
getAnywhere(plot.l)
class(tr)
getAnywhere(plot.party)
str(Pima.tr)
str(Pima.te)
?ctree
### Prepare data:
dcv <- rbind(Pima.tr, Pima.te)
d <- dcv
yname <- 'type'
### Check input:
stopifnot(is.factor(d[, yname]),
1<k_fold, k_fold<=nrow(X))
k_fold=10
### Check input:
stopifnot(is.factor(d[, yname]),
1<k_fold, k_fold<=nrow(X))
### Check input:
stopifnot(is.factor(d[, yname]),
1<k_fold, k_fold<=nrow(d))
### Create k sub-selections:
n <- nrow(d)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
indL
### Run KNN on each selection:
preds <- list()   # Create empty list
i <- 1
ind_fold <- indL[[i]]
trainDat <- d[ind_fold,]
trainDat
testDat <- d[-ind_fold,]
testDat
str(trainDat)
str(testDat)
testDat <- d[ind_fold,]
trainDat <- d[-ind_fold,]
str(trainDat)
str(testDat)
### Check input:
stopifnot(is.factor(d[, yname]),
1<k_fold, k_fold<=nrow(d), yname %in% colnames(d))
### Create k sub-selections:
n <- nrow(d)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
i
ind_fold <- indL[[i]]
testDat <- d[ind_fold,]
trainDat <- d[-ind_fold,]
colnames(d)
### Fit tree:
xnames <- colnames(d)[colnames(d)!= yname]
xnames
trform <- paste(yname, '~.')
trform
trform <- as.formula(paste(yname, '~.'))
trform
trform <- as.formula(paste0(yname, '~.'))
trform
trform <- as.formula(paste(yname, '~.'))
trform
rm(xnames)
treefit <- partykit::ctree(formula = trform, data=d)
plot(treefit)
treefit <- partykit::ctree(formula = trform, data=Pima.tr)
plot(treefit)
ind_fold <- indL[[i]]
testDat <- d[ind_fold,]
trainDat <- d[-ind_fold,]
### Fit tree:
trform <- as.formula(paste(yname, '~.'))   # Prepare formula
treefit <- partykit::ctree(formula = trform, data=d)
plot(treefit)
### Make prediction:
predict(treefit)
### Make prediction:
predict(treefit, type='response')
### Make prediction:
trpreds <- predict(treefit, type='response')
trpreds
trpreds0 <- predict(treefit, newdata = d, type='response')
identical(trpreds, trpreds0)
trpreds0
str(trpreds)
str(trpreds0)
as.numeric(trpreds)
as.numeric(trpreds0)
as.numeric(trpreds) - as.numeric(trpreds0)
(as.numeric(trpreds) - as.numeric(trpreds0))==0
all((as.numeric(trpreds) - as.numeric(trpreds0))==0)
rm(trpreds0)
### Make prediction:
trpreds <- predict(treefit, type='response')
trpreds
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=d[, yname], "Prediction"=trpreds)
preds
### Create k sub-selections:
n <- nrow(d)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- d[ind_fold,]
trainDat <- d[-ind_fold,]
### Fit tree:
trform <- as.formula(paste(yname, '~.'))   # Prepare formula
treefit <- partykit::ctree(formula = trform, data=d)
### Make prediction:
trpreds <- predict(treefit, type='response')
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=d[, yname], "Prediction"=trpreds)
}
predmrg <- do.call(rbind, preds)
### Confusion matrix:
confm <- table(predmrg)
confm
str(Pima.tr)
str(Pima.te)
### Check input:
stopifnot(is.factor(d[, yname]),
1<k_fold, k_fold<=nrow(d), yname %in% colnames(d))
### Create k sub-selections:
n <- nrow(d)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
i <- 1
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- d[ind_fold,]
trainDat <- d[-ind_fold,]
### Fit tree:
trform <- as.formula(paste(yname, '~.'))   # Prepare formula
treefit <- partykit::ctree(formula = trform, data=trainDat)
treefit
### Make prediction:
trpreds <- predict(treefit, type='response')
### Make prediction:
trpreds <- predict(treefit, newdata = testDat, type='response')
trpreds
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=testDat[, yname], "Prediction"=trpreds)
preds
### Check input:
stopifnot(is.factor(d[, yname]),
1<k_fold, k_fold<=nrow(d), yname %in% colnames(d))
### Create k sub-selections:
n <- nrow(d)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- d[ind_fold,]
trainDat <- d[-ind_fold,]
### Fit tree:
trform <- as.formula(paste(yname, '~.'))   # Prepare formula
treefit <- partykit::ctree(formula = trform, data=trainDat)
### Make prediction:
trpreds <- predict(treefit, newdata = testDat, type='response')
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=testDat[, yname], "Prediction"=trpreds)
}
predmrg <- do.call(rbind, preds)
predmrg
### Confusion matrix:
confm <- table(predmrg)
confm
sum(confm)
nrow(d)
### Confusion matrix:
confm <- table(predmrg)
### Error rate:
missMat <- confm
diag(missMat) <- 0
missCount <- sum(missMat)
testErr <- missCount/sum(confm)
### Return value:
rval <- list("ConfusionMatrix"=confm, "MissclassRate"=testErr)
rval
### Adapted cross validation function (for classiciation only):
classTree_crossVal <- function(d, yname, k_fold=10){
### Check input:
stopifnot(is.factor(d[, yname]),
1<k_fold, k_fold<=nrow(d), yname %in% colnames(d))
### Create k sub-selections:
n <- nrow(d)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- d[ind_fold,]
trainDat <- d[-ind_fold,]
### Fit tree:
trform <- as.formula(paste(yname, '~.'))   # Prepare formula
treefit <- partykit::ctree(formula = trform, data=trainDat)
### Make prediction:
trpreds <- predict(treefit, newdata = testDat, type='response')
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=testDat[, yname], "Prediction"=trpreds)
}
### Merge into one data frame:
### In one command:
# predmrg <- do.call(rbind, preds)
### Using a for loop instead:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
### Confusion matrix:
confm <- table(predmrg)
### Error rate:
missMat <- confm
diag(missMat) <- 0
missCount <- sum(missMat)
testErr <- missCount/sum(confm)
### Return value:
rval <- list("ConfusionMatrix"=confm, "MissclassRate"=testErr)
return(rval)
}
### Apply function:
classTree_crossVal(d = dcv, yname = 'type')
cvres <- classTree_crossVal(d = dcv, yname = 'type')
cvres
cvres$MissclassRate
round(cvres$MissclassRate, 2)
round(cvres$MissclassRate, 3)
round(cvres$MissclassRate, 3)*100
